import { execSync } from 'child_process';

let playwrightModule = null;
let systemChromiumPath = null;

function findSystemChromium(logger = console) {
  if (systemChromiumPath) return systemChromiumPath;
  
  try {
    const result = execSync('which chromium', {
      encoding: 'utf8',
      timeout: 2000
    }).trim();
    
    if (result) {
      systemChromiumPath = result;
      return systemChromiumPath;
    }
  } catch (e) {
  }
  
  return null;
}

async function loadPlaywright() {
  if (!playwrightModule) {
    playwrightModule = await import('playwright');
  }
  return playwrightModule;
}

// ENHANCED stealth evasion scripts - bypasses JS fingerprinting
const EVASION_SCRIPTS = `
// 1. Hide webdriver flag
Object.defineProperty(navigator, 'webdriver', {
  get: () => undefined
});

// 2. Mock realistic plugins (typical Chrome setup)
Object.defineProperty(navigator, 'plugins', {
  get: () => {
    const plugins = [
      { name: 'Chrome PDF Plugin', filename: 'internal-pdf-viewer', description: 'Portable Document Format' },
      { name: 'Chrome PDF Viewer', filename: 'mhjfbmdgcfjbbpaeojofohoefgiehjai', description: '' },
      { name: 'Native Client', filename: 'internal-nacl-plugin', description: '' }
    ];
    plugins.length = 3;
    return plugins;
  }
});

// 3. Mock realistic languages
Object.defineProperty(navigator, 'languages', {
  get: () => ['en-US', 'en']
});

// 4. Remove automation flags
window.chrome = {
  runtime: {},
  loadTimes: function() {},
  csi: function() {},
  app: {}
};

// 5. CRITICAL: Mock hardwareConcurrency (bots often show unusual values)
Object.defineProperty(navigator, 'hardwareConcurrency', {
  get: () => 8 // Realistic for modern computers
});

// 6. CRITICAL: Mock deviceMemory
Object.defineProperty(navigator, 'deviceMemory', {
  get: () => 8 // 8GB RAM is common
});

// 7. WebGL vendor spoofing (bots often show "Google SwiftShader")
const getParameter = WebGLRenderingContext.prototype.getParameter;
WebGLRenderingContext.prototype.getParameter = function(parameter) {
  // UNMASKED_VENDOR_WEBGL
  if (parameter === 37445) {
    return 'Intel Inc.';
  }
  // UNMASKED_RENDERER_WEBGL
  if (parameter === 37446) {
    return 'Intel Iris OpenGL Engine';
  }
  return getParameter.call(this, parameter);
};

// 8. Mock permissions API
const originalQuery = window.navigator.permissions.query;
window.navigator.permissions.query = (parameters) => (
  parameters.name === 'notifications' ?
    Promise.resolve({ state: Notification.permission }) :
    originalQuery(parameters)
);

// 9. Add realistic user timing
if (!window.performance.timing.navigationStart) {
  Object.defineProperty(window.performance.timing, 'navigationStart', {
    get: () => Date.now() - Math.floor(Math.random() * 1000)
  });
}

// 10. Hide automation in iframe (some stores check this)
Object.defineProperty(HTMLIFrameElement.prototype, 'contentWindow', {
  get: function() {
    const win = Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow').get.call(this);
    if (win) {
      try {
        win.navigator.webdriver = undefined;
      } catch (e) {}
    }
    return win;
  }
});

// 11. Mock connection type
Object.defineProperty(navigator, 'connection', {
  get: () => ({
    effectiveType: '4g',
    downlink: 10,
    rtt: 50,
    saveData: false
  })
});

// 12. Mock battery API
navigator.getBattery = () => Promise.resolve({
  charging: true,
  chargingTime: 0,
  dischargingTime: Infinity,
  level: 1
});
`;

// Detect department store and return specific handling strategy
function detectDepartmentStore(url) {
  const hostname = new URL(url).hostname.toLowerCase();
  
  const stores = {
    'nordstrom.com': {
      name: 'Nordstrom',
      waitTime: 6000, // Increased wait time
      priceSelectors: [
        '[data-testid="price-regular"]',
        '[data-testid="price-sale"]',
        '.price',
        '[class*="Price"]'
      ],
      needsScroll: true,
      extraDelay: 2000 // Extra time after human behavior
    },
    'saksfifthavenue.com': {
      name: 'Saks Fifth Avenue',
      waitTime: 5000,
      priceSelectors: [
        '[data-test="product-price"]',
        '.product-price',
        '[class*="price"]'
      ],
      needsScroll: true,
      extraDelay: 1500
    },
    'neimanmarcus.com': {
      name: 'Neiman Marcus',
      waitTime: 4000,
      priceSelectors: [
        '[data-testid="price"]',
        '.price-sale',
        '[class*="Price"]'
      ],
      needsScroll: true
    },
    'bloomingdales.com': {
      name: 'Bloomingdales',
      waitTime: 4000,
      priceSelectors: [
        '#priceSale',
        '.currentPrice',
        '[class*="price"]'
      ],
      needsScroll: false
    },
    'bergdorfgoodman.com': {
      name: 'Bergdorf Goodman',
      waitTime: 4000,
      priceSelectors: [
        '.product-price',
        '[data-testid="price"]'
      ],
      needsScroll: true
    }
  };
  
  for (const [domain, config] of Object.entries(stores)) {
    if (hostname.includes(domain)) {
      return config;
    }
  }
  
  return null;
}

// IMPROVED: More realistic human behavior with randomization
async function simulateHumanBehavior(page, logger) {
  try {
    logger.log('[Stealth] Simulating human behavior...');
    
    // Random initial position
    const startX = 50 + Math.random() * 100;
    const startY = 50 + Math.random() * 100;
    
    // Move mouse in a curve (humans don't move in straight lines)
    await page.mouse.move(startX, startY);
    await page.waitForTimeout(100 + Math.random() * 200);
    
    const midX = 200 + Math.random() * 300;
    const midY = 200 + Math.random() * 300;
    await page.mouse.move(midX, midY);
    await page.waitForTimeout(150 + Math.random() * 250);
    
    const endX = 400 + Math.random() * 200;
    const endY = 400 + Math.random() * 200;
    await page.mouse.move(endX, endY);
    await page.waitForTimeout(100 + Math.random() * 200);
    
    // Scroll down in multiple small steps (humans don't scroll in one go)
    for (let i = 0; i < 3; i++) {
      await page.evaluate((step) => {
        window.scrollBy({
          top: 150 + Math.random() * 100,
          behavior: 'smooth'
        });
      }, i);
      await page.waitForTimeout(400 + Math.random() * 600);
    }
    
    // Pause to "read" (humans take time)
    await page.waitForTimeout(800 + Math.random() * 1200);
    
    // Scroll back up slowly
    await page.evaluate(() => {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    });
    await page.waitForTimeout(500 + Math.random() * 500);
    
    // Random mouse wiggle at the end
    await page.mouse.move(endX + 10, endY + 10);
    await page.waitForTimeout(100);
    await page.mouse.move(endX - 5, endY + 5);
    
    logger.log('[Stealth] Human behavior simulation complete');
  } catch (error) {
    logger.warn('[Stealth] Human behavior simulation failed:', error.message);
  }
}

export async function scrapeWithPlaywright(url, options = {}) {
  const { logger = console } = options;
  const startTime = Date.now();
  let browser = null;
  let context = null;
  
  try {
    logger.log('[Playwright] Starting stealth scraper for:', url);
    
    const storeConfig = detectDepartmentStore(url);
    if (storeConfig) {
      logger.log(`[Stealth] Detected ${storeConfig.name} - using specialized handling`);
    }
    
    process.env.PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS = 'true';
    
    const { chromium } = await loadPlaywright();
    const chromiumPath = findSystemChromium(logger);
    
    const launchOptions = {
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--disable-blink-features=AutomationControlled', // CRITICAL: Hide automation
        '--disable-features=IsolateOrigins,site-per-process',
        '--disable-web-security',
        '--disable-features=VizDisplayCompositor'
      ]
    };
    
    if (chromiumPath) {
      logger.log('[Playwright] Using system Chromium:', chromiumPath);
      launchOptions.executablePath = chromiumPath;
    }
    
    browser = await chromium.launch(launchOptions);
    
    // IMPROVED: More realistic browser context
    context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      viewport: { width: 1920, height: 1080 },
      locale: 'en-US',
      timezoneId: 'America/New_York',
      geolocation: { latitude: 40.7128, longitude: -74.0060 }, // NYC
      permissions: ['geolocation'],
      deviceScaleFactor: 1,
      isMobile: false,
      hasTouch: false,
      colorScheme: 'light',
      extraHTTPHeaders: {
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept-Encoding': 'gzip, deflate, br',
        'DNT': '1',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Cache-Control': 'max-age=0'
      }
    });
    
    const page = await context.newPage();
    
    // CRITICAL: Inject stealth scripts BEFORE navigation
    await page.addInitScript(EVASION_SCRIPTS);
    
    logger.log('[Playwright] Navigating to page with stealth...');
    
    // Set a realistic referer for department stores
    if (storeConfig) {
      await page.setExtraHTTPHeaders({
        'Referer': `https://${new URL(url).hostname}/`
      });
    }
    
    try {
      const response = await page.goto(url, { 
        waitUntil: 'domcontentloaded',
        timeout: 35000
      });
      
      logger.log(`[Playwright] Response status: ${response.status()}`);
      
      // Check if we got blocked
      if (response.status() === 403 || response.status() === 429) {
        logger.error('[Playwright] Got blocked by bot detection (403/429)');
        throw new Error(`Bot detection: HTTP ${response.status()}`);
      }
      
    } catch (navError) {
      logger.error('[Playwright] Navigation failed:', navError.message);
      throw new Error(`Navigation failed: ${navError.message}`);
    }
    
    // IMPROVED: Wait strategy based on store type
    const waitTime = storeConfig?.waitTime || 3000;
    logger.log(`[Playwright] Waiting ${waitTime}ms for content to render...`);
    
    await page.waitForTimeout(waitTime);
    
    // CRITICAL: Simulate human behavior for department stores
    if (storeConfig && storeConfig.needsScroll) {
      await simulateHumanBehavior(page, logger);
      
      // Extra delay for particularly strict stores
      if (storeConfig.extraDelay) {
        logger.log(`[Stealth] Extra delay: ${storeConfig.extraDelay}ms`);
        await page.waitForTimeout(storeConfig.extraDelay);
      }
    }
    
    // Wait for key elements
    try {
      await page.waitForSelector('body', { timeout: 5000 });
      logger.log('[Playwright] Body loaded');
    } catch (e) {
      logger.warn('[Playwright] Body selector timeout');
    }
    
    // CRITICAL: Check for bot detection pages
    logger.log('[Stealth] Checking for bot detection pages...');
    const isBotPage = await page.evaluate(() => {
      const bodyText = document.body.innerText.toLowerCase();
      const title = document.title.toLowerCase();
      
      // Common bot detection phrases
      const botPhrases = [
        'unusual activity',
        'verify you are human',
        'are you a robot',
        'access denied',
        'security check',
        'captcha',
        'blocked',
        'suspicious activity',
        'please verify',
        'automated access',
        'not a robot'
      ];
      
      // Check if any phrase appears
      const foundPhrase = botPhrases.find(phrase => 
        bodyText.includes(phrase) || title.includes(phrase)
      );
      
      if (foundPhrase) {
        return { detected: true, reason: foundPhrase };
      }
      
      // Check for CAPTCHA elements
      const hasCaptcha = document.querySelector('[class*="captcha"]') ||
                        document.querySelector('[id*="captcha"]') ||
                        document.querySelector('iframe[src*="recaptcha"]') ||
                        document.querySelector('iframe[src*="captcha"]');
      
      if (hasCaptcha) {
        return { detected: true, reason: 'captcha element found' };
      }
      
      return { detected: false };
    });
    
    if (isBotPage.detected) {
      logger.error(`[Stealth] ❌ Bot detection page detected: "${isBotPage.reason}"`);
      
      // Take screenshot of bot detection page
      await page.screenshot({ path: '/tmp/playwright-bot-detected.png', fullPage: true });
      logger.log('[Stealth] Bot detection screenshot: /tmp/playwright-bot-detected.png');
      
      // Try to get the page HTML for analysis
      const pageHtml = await page.content();
      logger.log('[Stealth] Page HTML preview:', pageHtml.substring(0, 500));
      
      throw new Error(`Bot detection triggered: ${isBotPage.reason}`);
    }
    
    logger.log('[Stealth] ✅ No bot detection - proceeding with extraction');
    
    // Take screenshot for debugging (optional)
    try {
      await page.screenshot({ path: '/tmp/playwright-scrape.png', fullPage: false });
      logger.log('[Playwright] Screenshot saved: /tmp/playwright-scrape.png');
    } catch (e) {
      logger.warn('[Playwright] Screenshot failed:', e.message);
    }
    
    logger.log('[Playwright] Extracting product data...');
    
    // IMPROVED: Extract data with better selectors and validation
    const productData = await page.evaluate((storeConfig) => {
      const data = {
        name: null,
        imageUrl: null,
        originalPrice: null,
        salePrice: null,
        percentOff: 0,
        brand: null
      };
      
      // Extract name
      const nameSelectors = [
        'h1',
        '[data-testid*="product-title"]',
        '[data-test*="product-title"]',
        '[class*="product-title"]',
        '[class*="ProductTitle"]',
        '[class*="ProductName"]',
        '[itemprop="name"]',
        'meta[property="og:title"]'
      ];
      
      for (const selector of nameSelectors) {
        const element = document.querySelector(selector);
        if (element) {
          data.name = selector.includes('meta') 
            ? element.getAttribute('content')
            : element.textContent?.trim();
          if (data.name) break;
        }
      }
      
      if (!data.name) {
        data.name = document.title.split('|')[0].trim();
      }
      
      // Extract brand
      const brandSelectors = [
        '[data-testid*="brand"]',
        '[class*="brand"]',
        '[class*="designer"]',
        '[itemprop="brand"]'
      ];
      
      for (const selector of brandSelectors) {
        const element = document.querySelector(selector);
        if (element) {
          data.brand = element.textContent?.trim();
          if (data.brand) break;
        }
      }
      
      // Extract image
      const imageSelectors = [
        'meta[property="og:image"]',
        'meta[name="og:image"]',
        'meta[property="twitter:image"]',
        '[data-testid*="product-image"] img',
        '[class*="product-image"] img',
        '[class*="ProductImage"] img',
        'img[class*="main"]',
        'img[itemprop="image"]'
      ];
      
      for (const selector of imageSelectors) {
        const element = document.querySelector(selector);
        if (element) {
          data.imageUrl = selector.includes('meta')
            ? element.getAttribute('content')
            : element.src || element.getAttribute('data-src');
          if (data.imageUrl && data.imageUrl.startsWith('http')) break;
        }
      }
      
      // Extract prices with store-specific selectors
      let priceSelectors = [
        '[data-testid*="price"]',
        '[data-test*="price"]',
        '[class*="price-sale"]',
        '[class*="sale-price"]',
        '[class*="current-price"]',
        '[class*="currentPrice"]',
        '[class*="Price--sale"]',
        '.price',
        '[itemprop="price"]'
      ];
      
      // Add store-specific selectors if available
      if (storeConfig && storeConfig.priceSelectors) {
        priceSelectors = [...storeConfig.priceSelectors, ...priceSelectors];
      }
      
      const originalPriceSelectors = [
        '[data-testid*="price-regular"]',
        '[data-testid*="original"]',
        '[class*="price-original"]',
        '[class*="original-price"]',
        '[class*="regular-price"]',
        '[class*="regularPrice"]',
        '[class*="was-price"]',
        '[class*="compare-at-price"]',
        '[class*="Price--original"]',
        's [class*="price"]', // Strikethrough prices
        'del [class*="price"]',
        '[itemprop="highPrice"]'
      ];
      
      const extractPrice = (element) => {
        if (!element) return null;
        
        // Try content attribute first (structured data)
        const content = element.getAttribute('content');
        if (content) {
          const num = parseFloat(content.replace(/[^0-9.]/g, ''));
          if (!isNaN(num) && num > 0) return num;
        }
        
        // Try text content
        const text = element.textContent || '';
        const priceMatch = text.match(/\$?\s*([0-9,]+\.?\d{0,2})/);
        if (priceMatch) {
          const num = parseFloat(priceMatch[1].replace(/,/g, ''));
          if (!isNaN(num) && num > 0) return num;
        }
        
        return null;
      };
      
      // Find sale price
      for (const selector of priceSelectors) {
        const elements = document.querySelectorAll(selector);
        for (const element of elements) {
          const price = extractPrice(element);
          if (price) {
            data.salePrice = price;
            break;
          }
        }
        if (data.salePrice) break;
      }
      
      // Find original price
      for (const selector of originalPriceSelectors) {
        const elements = document.querySelectorAll(selector);
        for (const element of elements) {
          const price = extractPrice(element);
          if (price && (!data.salePrice || price > data.salePrice)) {
            data.originalPrice = price;
            break;
          }
        }
        if (data.originalPrice) break;
      }
      
      // Calculate discount
      if (data.originalPrice && data.salePrice && data.originalPrice > data.salePrice) {
        data.percentOff = Math.round(((data.originalPrice - data.salePrice) / data.originalPrice) * 100);
      } else if (data.originalPrice && data.originalPrice <= data.salePrice) {
        // Prices are reversed or equal - no discount
        data.originalPrice = null;
        data.percentOff = 0;
      }
      
      return data;
    }, storeConfig);
    
    logger.log('[Playwright] Raw extracted data:', productData);
    
    // Normalize image URL
    const normalizeImageUrl = (imageUrl, pageUrl) => {
      if (!imageUrl) return null;
      if (imageUrl.startsWith('http')) return imageUrl;
      if (imageUrl.startsWith('//')) return 'https:' + imageUrl;
      
      try {
        const base = new URL(pageUrl);
        return new URL(imageUrl, base).href;
      } catch {
        return null;
      }
    };
    
    productData.imageUrl = normalizeImageUrl(productData.imageUrl, url);
    
    // Calculate confidence score
    let confidence = 70;
    
    if (!productData.name) {
      confidence -= 30;
      logger.warn('[Playwright] No product name found');
    }
    if (!productData.imageUrl) {
      confidence -= 20;
      logger.warn('[Playwright] No image URL found');
    }
    if (!productData.salePrice || productData.salePrice === 0) {
      confidence -= 20;
      logger.warn('[Playwright] No sale price found');
    }
    
    // Check for placeholder images
    if (productData.imageUrl && (
      productData.imageUrl.includes('example.com') ||
      productData.imageUrl.includes('placeholder') ||
      productData.imageUrl.includes('data:image')
    )) {
      confidence -= 20;
      logger.warn('[Playwright] Placeholder image detected');
    }
    
    // Boost confidence for department stores (they're harder to scrape)
    if (storeConfig) {
      confidence += 10;
      logger.log(`[Stealth] Confidence boost for ${storeConfig.name}`);
    }
    
    if (confidence < 50) {
      throw new Error(`Playwright extraction failed: confidence too low (${confidence}%)`);
    }
    
    if (!productData.name || !productData.imageUrl || !productData.salePrice) {
      throw new Error('Missing required product fields (name, imageUrl, or salePrice)');
    }
    
    logger.log(`✅ [Playwright] Extracted product (confidence: ${confidence}%):`, {
      name: productData.name,
      brand: productData.brand,
      salePrice: productData.salePrice,
      originalPrice: productData.originalPrice
    });
    
    return {
      success: true,
      product: {
        name: productData.name,
        brand: productData.brand || null,
        imageUrl: productData.imageUrl,
        originalPrice: productData.originalPrice,
        salePrice: productData.salePrice,
        percentOff: productData.percentOff || 0,
        url: url,
        confidence: confidence
      },
      meta: {
        method: 'playwright',
        phase: 'browser-extraction',
        confidence: confidence,
        durationMs: Date.now() - startTime,
        store: storeConfig?.name || 'unknown'
      }
    };
    
  } catch (error) {
    logger.error('[Playwright] Error:', error.message);
    return {
      success: false,
      error: error.message,
      meta: {
        method: 'playwright',
        phase: 'error',
        confidence: 0,
        durationMs: Date.now() - startTime
      }
    };
  } finally {
    if (context) {
      try {
        await context.close();
      } catch (e) {
        logger.error('[Playwright] Error closing context:', e.message);
      }
    }
    if (browser) {
      try {
        await browser.close();
      } catch (e) {
        logger.error('[Playwright] Error closing browser:', e.message);
      }
    }
  }
}