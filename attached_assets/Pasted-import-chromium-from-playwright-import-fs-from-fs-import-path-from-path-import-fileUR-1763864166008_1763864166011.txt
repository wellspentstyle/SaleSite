import { chromium } from 'playwright';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const MARKER_FILE = path.join(__dirname, 'gem-sync-state.json');
const AIRTABLE_PAT = process.env.AIRTABLE_PAT;

// Auto-detect environment and use appropriate Airtable base
const isProduction = !!process.env.REPLIT_DEPLOYMENT;
const AIRTABLE_BASE_ID = isProduction 
  ? process.env.AIRTABLE_BASE_ID 
  : (process.env.AIRTABLE_BASE_ID_DEV || process.env.AIRTABLE_BASE_ID);

const GEM_TABLE_NAME = 'Gem';

function readMarker() {
  try {
    if (fs.existsSync(MARKER_FILE)) {
      const data = fs.readFileSync(MARKER_FILE, 'utf-8');
      return JSON.parse(data);
    }
  } catch (error) {
    console.log('‚ö†Ô∏è  Could not read marker file:', error.message);
  }
  return { lastItemId: null, lastSyncDate: null };
}

function writeMarker(itemId) {
  try {
    const data = {
      lastItemId: itemId,
      lastSyncDate: new Date().toISOString()
    };
    fs.writeFileSync(MARKER_FILE, JSON.stringify(data, null, 2));
    console.log('üìù Updated marker file with item ID:', itemId);
  } catch (error) {
    console.error('‚ùå Failed to write marker file:', error.message);
  }
}

async function saveItemsToAirtable(items) {
  if (items.length === 0) {
    console.log('‚ö†Ô∏è  No items to save to Airtable');
    return { success: true, count: 0 };
  }

  try {
    console.log(`üíæ Saving ${items.length} items to Airtable...`);

    const records = items.map(item => ({
      fields: {
        ProductName: item.name,
        ProductURL: item.url,
        Brand: item.brand,
        Price: item.price,
        Size: item.size,
        ImageURL: item.imageUrl,
        DateSaved: item.dateSaved,
        Marketplace: item.marketplace
      }
    }));

    const BATCH_SIZE = 10;
    const savedRecords = [];

    for (let i = 0; i < records.length; i += BATCH_SIZE) {
      const batch = records.slice(i, i + BATCH_SIZE);

      const response = await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${GEM_TABLE_NAME}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${AIRTABLE_PAT}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ records: batch })
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Airtable error:', errorText);
        throw new Error(`Airtable error: ${response.status}`);
      }

      const data = await response.json();
      savedRecords.push(...data.records);
      console.log(`‚úÖ Saved batch ${Math.floor(i / BATCH_SIZE) + 1}: ${data.records.length} items`);
    }

    console.log(`‚úÖ Total saved to Airtable: ${savedRecords.length} items`);
    return { success: true, count: savedRecords.length };

  } catch (error) {
    console.error('‚ùå Error saving to Airtable:', error.message);
    return { success: false, error: error.message };
  }
}

export async function scrapeGemItems(magicLink, options = {}) {
  const { maxItems = 5, logger = console } = options;
  
  logger.log('üöÄ Starting Gem scraper...');
  logger.log(`üìß Using magic link authentication`);
  logger.log(`üî¢ Max items to scrape: ${maxItems}`);

  const marker = readMarker();
  logger.log('üìç Last synced item ID:', marker.lastItemId || 'none (first run)');

  let browser;
  let page;
  
  try {
    // Try to find Chromium executable
    let chromiumPath = null;
    try {
      chromiumPath = execSync('which chromium', { encoding: 'utf-8' }).trim();
      logger.log(`‚úÖ Found Chromium at: ${chromiumPath}`);
    } catch (e) {
      logger.log('‚ö†Ô∏è  Could not find chromium with which, trying default path...');
    }
    
    const launchOptions = {
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--no-first-run',
        '--no-zygote',
        '--disable-gpu',
        '--disable-blink-features=AutomationControlled'
      ]
    };
    
    if (chromiumPath) {
      launchOptions.executablePath = chromiumPath;
    }
    
    logger.log('üöÄ Launching browser...');
    browser = await chromium.launch(launchOptions);

    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      viewport: { width: 1920, height: 1080 },
      locale: 'en-US',
      timezoneId: 'America/New_York'
    });

    page = await context.newPage();

    // IMPROVED: Better magic link authentication with verification
    logger.log('üîê Navigating to magic link...');
    logger.log(`üîó Magic link: ${magicLink.substring(0, 50)}...`);
    
    try {
      const response = await page.goto(magicLink, { 
        waitUntil: 'networkidle', 
        timeout: 45000 
      });
      
      logger.log(`üìä Response status: ${response.status()}`);
      logger.log(`üìç Current URL after magic link: ${page.url()}`);
      
      // Take screenshot for debugging
      await page.screenshot({ path: '/tmp/gem-auth-1-after-link.png', fullPage: true });
      logger.log('üì∏ Screenshot saved: /tmp/gem-auth-1-after-link.png');
      
    } catch (navError) {
      logger.error(`‚ùå Failed to navigate to magic link: ${navError.message}`);
      throw new Error(`Magic link navigation failed: ${navError.message}`);
    }

    // IMPROVED: Wait for authentication to complete and verify success
    logger.log('‚è≥ Waiting for authentication to complete...');
    
    // Wait for one of these to happen (whichever comes first):
    // 1. Redirect to gem.app home/dashboard (success)
    // 2. Stay on login page (failure)
    // 3. Error page
    
    await page.waitForTimeout(3000);
    
    const currentUrl = page.url();
    logger.log(`üìç Current URL after wait: ${currentUrl}`);
    
    // Check if we're authenticated by looking for signs of logged-in state
    const isAuthenticated = await page.evaluate(() => {
      // Check for common auth indicators
      const hasUserMenu = document.querySelector('[data-testid="user-menu"]') !== null;
      const hasProfileLink = document.querySelector('a[href*="/profile"]') !== null;
      const hasMyGemsLink = document.querySelector('a[href*="/my-gems"]') !== null;
      const hasLogoutButton = document.querySelector('button:has-text("Log out")') !== null;
      
      // Check if we're NOT on login page
      const notOnLoginPage = !window.location.href.includes('/login') && 
                             !window.location.href.includes('/requestEmailLogIn');
      
      return (hasUserMenu || hasProfileLink || hasMyGemsLink || hasLogoutButton) && notOnLoginPage;
    });
    
    logger.log(`üîê Authentication check: ${isAuthenticated ? 'SUCCESS' : 'FAILED'}`);
    
    if (!isAuthenticated) {
      // Take screenshot of failure state
      await page.screenshot({ path: '/tmp/gem-auth-2-failed.png', fullPage: true });
      logger.log('üì∏ Failed auth screenshot: /tmp/gem-auth-2-failed.png');
      
      // Get page title and any error messages
      const title = await page.title();
      const errorText = await page.evaluate(() => {
        const errorEl = document.querySelector('[class*="error"]') || 
                       document.querySelector('[role="alert"]');
        return errorEl ? errorEl.textContent : null;
      });
      
      logger.error(`‚ùå Authentication failed. Page title: "${title}"`);
      if (errorText) {
        logger.error(`‚ùå Error message: ${errorText}`);
      }
      
      throw new Error('Magic link authentication failed - not logged in after using link');
    }
    
    logger.log('‚úÖ Successfully authenticated!');
    await page.screenshot({ path: '/tmp/gem-auth-3-success.png', fullPage: true });
    logger.log('üì∏ Success screenshot: /tmp/gem-auth-3-success.png');

    // IMPROVED: Navigate to saved items with better error handling
    logger.log('üì± Navigating to my-gems page...');
    
    try {
      await page.goto('https://gem.app/my-gems', { 
        waitUntil: 'domcontentloaded', 
        timeout: 30000 
      });
      
      logger.log(`üìç Current URL: ${page.url()}`);
      
      // Wait for items to load
      logger.log('‚è≥ Waiting for items to load...');
      
      // Try multiple selectors that might indicate items are loaded
      const itemsLoaded = await Promise.race([
        page.waitForSelector('[data-testid="gem-card"]', { timeout: 10000 }).then(() => true),
        page.waitForSelector('.gem-card', { timeout: 10000 }).then(() => true),
        page.waitForSelector('article', { timeout: 10000 }).then(() => true),
        page.waitForTimeout(10000).then(() => false)
      ]);
      
      if (!itemsLoaded) {
        logger.log('‚ö†Ô∏è  No item selectors found, but continuing anyway...');
      } else {
        logger.log('‚úÖ Items loaded successfully');
      }
      
      await page.screenshot({ path: '/tmp/gem-items-page.png', fullPage: true });
      logger.log('üì∏ Items page screenshot: /tmp/gem-items-page.png');
      
    } catch (navError) {
      logger.error(`‚ùå Failed to navigate to my-gems: ${navError.message}`);
      await page.screenshot({ path: '/tmp/gem-nav-error.png', fullPage: true });
      throw new Error(`Navigation to my-gems failed: ${navError.message}`);
    }

    logger.log('üîç Extracting saved items...');

    const items = await page.evaluate((lastItemId) => {
      const results = [];
      
      // Try multiple selectors for item cards
      const selectors = [
        '[data-testid="gem-card"]',
        '.gem-card',
        'article',
        '[class*="card"]',
        '[class*="item"]',
        '[class*="product"]'
      ];
      
      let itemCards = [];
      for (const selector of selectors) {
        itemCards = document.querySelectorAll(selector);
        if (itemCards.length > 0) {
          console.log(`Found ${itemCards.length} items with selector: ${selector}`);
          break;
        }
      }
      
      if (itemCards.length === 0) {
        console.log('No item cards found on page');
        return results;
      }

      for (const card of itemCards) {
        try {
          // Find link
          const linkElement = card.querySelector('a[href*="http"]') || card.querySelector('a');
          if (!linkElement) continue;

          const url = linkElement.href;
          if (!url || url.includes('gem.app')) continue;

          // Find image
          const imgElement = card.querySelector('img');
          const imageUrl = imgElement?.src || '';

          // Get all text content
          const textContent = card.innerText || '';
          const lines = textContent.split('\n').map(l => l.trim()).filter(l => l);

          // Extract price
          const priceMatch = textContent.match(/\$[\d,]+(?:\.\d{2})?/);
          const price = priceMatch ? parseFloat(priceMatch[0].replace(/[$,]/g, '')) : null;

          // Extract size
          const sizeMatch = textContent.match(/size[:\s]*([^\n]+)/i);
          const size = sizeMatch ? sizeMatch[1].trim() : null;

          // Extract name and brand
          let name = '';
          let brand = '';

          for (const line of lines) {
            if (line.startsWith('$') || line.match(/^\d+$/)) continue;
            if (line.toLowerCase().includes('size')) continue;
            if (line.toLowerCase().includes('save') || line.toLowerCase().includes('share')) continue;

            if (!brand && line.length < 50) {
              brand = line;
            } else if (!name) {
              name = line;
              break;
            }
          }

          // Extract marketplace
          const urlObj = new URL(url);
          const marketplace = urlObj.hostname.replace(/^www\./, '');

          // Create unique item ID
          const itemId = url + '||' + (name || 'unnamed');

          // Stop if we've reached the last synced item
          if (itemId === lastItemId) {
            console.log('Reached last synced item, stopping');
            return results;
          }

          results.push({
            id: itemId,
            name: name || 'Unnamed Item',
            url: url,
            brand: brand || null,
            price: price,
            size: size,
            imageUrl: imageUrl,
            marketplace: marketplace,
            dateSaved: new Date().toISOString().split('T')[0]
          });

        } catch (error) {
          console.error('Error extracting item:', error);
        }
      }

      return results;
    }, marker.lastItemId);

    logger.log(`‚úÖ Extracted ${items.length} items from page`);

    if (items.length === 0) {
      logger.log('‚ö†Ô∏è  No items found on page. This could mean:');
      logger.log('   1. You have no saved items in Gem');
      logger.log('   2. The page structure changed');
      logger.log('   3. Items failed to load');
      
      // Get page HTML for debugging
      const bodyText = await page.evaluate(() => document.body.innerText);
      logger.log('üìÑ Page text preview:', bodyText.substring(0, 500));
    }

    await browser.close();

    const itemsToSave = items.slice(0, maxItems);
    logger.log(`üì¶ Saving ${itemsToSave.length} items (limited to max ${maxItems})`);

    const saveResult = await saveItemsToAirtable(itemsToSave);

    if (saveResult.success && itemsToSave.length > 0) {
      writeMarker(itemsToSave[0].id);
    }

    return {
      success: true,
      itemsScraped: items.length,
      itemsSaved: saveResult.count,
      items: itemsToSave,
      message: `Successfully scraped ${items.length} items, saved ${saveResult.count} to Airtable`
    };

  } catch (error) {
    logger.error('‚ùå Gem scraper error:', error.message);
    logger.error('Stack trace:', error.stack);
    
    // Try to get current page state for debugging
    if (page) {
      try {
        const url = page.url();
        const title = await page.title();
        logger.error(`‚ùå Error occurred at URL: ${url}`);
        logger.error(`‚ùå Page title: ${title}`);
        await page.screenshot({ path: '/tmp/gem-error-state.png', fullPage: true });
        logger.error('üì∏ Error state screenshot: /tmp/gem-error-state.png');
      } catch (debugError) {
        logger.error('‚ö†Ô∏è  Could not capture debug info:', debugError.message);
      }
    }
    
    if (browser) {
      await browser.close();
    }

    return {
      success: false,
      error: error.message,
      itemsScraped: 0,
      itemsSaved: 0
    };
  }
}